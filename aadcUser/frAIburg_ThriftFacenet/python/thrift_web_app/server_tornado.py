#!/usr/bin/python
"""Tornado powered Thrift HTTP server - accepts both POST and web socket transport protocols
based on https://omri.org.il/2012/12/22/python-tornado-apache-thrift-and-javascript/
 """
import sys
sys.path.append('./gen-py')

import os

import socket #get local localhost

# files generated by thrift
from newservice import NewService
from newservice.ttypes import *


from thrift.server import TServer
# js only supports the TJSONProtocold
from thrift.protocol import TJSONProtocol
from newservicehandler import NewServiceHandler

#web server with tornado
import tornado
import tornado.httpserver
from tornado.web import RequestHandler
from tornado.websocket import WebSocketHandler


class DualHandler(WebSocketHandler):
    """This class lets you implement WebSocket and RequestHandler
    (except for the get() method) in the same class.
    I couldn't find any reason why not to use the same handler both for
    websockets and POST calls, however, tornado doesn't let you do it.
    This is my workaround.
    """

    def _execute(self, *args, **kwargs):
        """Does the exact same thing like WebSocketHandler._execute() for GET
        requests. Otherwise, acts like RequestHandler.
        """
        if self.request.method == 'GET':
            # dispatch to WebSocketHandler
            WebSocketHandler._execute(self, *args, **kwargs)
        else:
            # remap unsupported WebSocketHandler methods back to RequestHandler
            # the __get__(self, DualHandler) trick is used to bind the methods
            # back to the object, otherwise it's unbound
            for method in ["write", "redirect", "set_header", "send_error",
                           "set_cookie", "set_status", "flush", "finish"]:
                    setattr(self, method,
                            getattr(RequestHandler, method).__get__(
                                    self, DualHandler))

            # dispatch to RequestHandler
            RequestHandler._execute(self, *args, **kwargs)


class ThriftDualHandler(DualHandler, TServer.TServer):
    ''' handling Thrift with Tornado '''
    def initialize(self, processor, inputProtocolFactory,
                  outputProtocolFactory):
        TServer.TServer.__init__(self, processor, None, None, None,
            inputProtocolFactory, outputProtocolFactory)

    def post(self):
        self.set_header('Content-Type', 'application/x-thrift')
        self.write(self.handle_request(self.request.body))

    def on_message(self, message):
        self.write_message(self.handle_request(message))

    def handle_request(self, data):
        itrans = TTransport.TMemoryBuffer(data)
        otrans = TTransport.TMemoryBuffer()
        iprot = self.inputProtocolFactory.getProtocol(itrans)
        oprot = self.outputProtocolFactory.getProtocol(otrans)
        self.processor.process(iprot, oprot)
        return otrans.getvalue()


class FrAIburgApplication(tornado.web.Application):
    def __init__(self):
        handler = NewServiceHandler()
        processor = NewService.Processor(handler)
        pfactory = TJSONProtocol.TJSONProtocolFactory()
        settings = [
            (r"/thrift", ThriftDualHandler,
                dict(processor = processor,
                inputProtocolFactory = pfactory,
                outputProtocolFactory = pfactory)),
            (r"/static/(.*)", tornado.web.StaticFileHandler,
                {"path": os.path.join(os.path.dirname(__file__), "static"),
                 "default_filename" : "index.html"}),
             ]
        tornado.web.Application.__init__(self, settings)


def print_web_app_address(port):
    try:
        print("start the Web App: http://%s:%d/static/index.html"
        % (socket.gethostbyname(socket.gethostname()), port))
    except Exception :
        print("start the Web App: http://localhost:%d/static/index.html" %
            port)

def start_tornado_thrift_web_app(port = 8888):
    ''' start single thread tornado web server with thrift  '''

    application = FrAIburgApplication()
    print_web_app_address(port)
    application.listen(port)

    tornado.ioloop.IOLoop.instance().start()

def start_tornado_thrift_web_app_multiprocess(port = 8888 ,num_subprocesses = 2):
    '''multiprocess tornado web server with thrift  '''

    application = FrAIburgApplication()
    print_web_app_address(port)
    print("tornado HTTPServer with {} subprocesses".format(num_subprocesses))
    server = tornado.httpserver.HTTPServer(application)
    server.bind(port)

    server.start(num_subprocesses) # Forks multiple sub-processes
    tornado.ioloop.IOLoop.instance().start()


if __name__ == '__main__':
    #start_tornado_thrift_web_app(port = 8888)
    start_tornado_thrift_web_app_multiprocess(port = 8888, num_subprocesses = 2)
